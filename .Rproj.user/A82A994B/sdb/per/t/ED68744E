{
    "contents" : "#This code calculates DCIp and DCId\n#A large portion of the code is adapted from Greig Oldfords original work on FIPEX\n#It has been adapted to run using R 3.X.X and igraph\n#The workflow is largely consistent with Greig's earlier work and he should be cited appropriately\n\n####\n#FUNCTION - DCI.calc: calculates DCIp and DCId\n#REQUIRES a node file with the following colnames\n#ID: ID of the segment and barrier\n#Area: The length of the segment downstream of the barrier\n#Qual: Quality of the segment, currently not used\n#PermDS: downstream permeability of the barrier, this is usually 1\n#PermUS: upstream permeability of the barrier, ranges between 0 (impermeable) and 1 (permeable)\n#\n#REQUIRES a graph object that can be any dendritic network describing the structure of the network\n#mouth is the segment number that is the mouth of the river\n####\ngraphfile <- High.g\nnodefile <- Nodes\n\nlength(unique(nodefile$ID))\nunique(nodefile$ID)[2]\nk <-216\n\nnrow(nodefile)\n\nDCI.calc <- function(nodefile, graphfile, mouth){\n  #Construct a table with the start and end of each path between all segments, length of that path,\n  #the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment\n  all.paths <- NULL\n  for (b in 1:length(nodefile$ID)) {\n    k <- unique(nodefile$ID)[b]\n    paths <- all_simple_paths(graph=graphfile, from=k, mode = \"all\") #returns path from a segment to all other segements\n    start <- sapply(paths, \"[[\", 1) #Identify the starting segment\n    end <- sapply(paths, tail, 1) #Identify the final segment\n    p.length <- NULL \n    pass <- NULL\n    for (j in 1:(length(unique(nodefile$ID))-1)) {  \n      p.length2 <- 0\n      pass2 <- 1\n        for (c in paths[[j]]) {\n          i <- unique(nodefile$ID)[c]\n          p.length2 <- p.length2 + nodefile$Area[i] #length of the path\n          pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])\n        }\n      p.length <- c(p.length, p.length2)\n      pass <- c(pass, pass2)\n    }\n    all.paths2 <- data.frame(start, end, p.length, pass)\n    itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])\n    all.paths <- rbind(all.paths, all.paths2, itself)\n  }  \n  all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]\n  all.paths$End.Length <- nodefile$Area[match(all.paths$end, nodefile$ID)]\n\n  #DCIp Calculation\n  tot.length <- sum(nodefile$Area)\n  DCIp <- 0\n  for (i in 1:nrow(all.paths)) {\n    DCIp <- DCIp + (all.paths$pass[i] * (all.paths$Start.Length[i]/tot.length) * (all.paths$End.Length[i]/tot.length))\n  }\n\n  #Calculate DCId\n  DCId <- 0\n  DCId.data <- all.paths[all.paths$end==mouth, ]\n  for (i in 1:nrow(DCId.data)){\n    DCId <- DCId + (DCId.data$pass[i] * (DCId.data$Start.Length[i]/tot.length))\n  }\n\n  DCI.results <- data.frame(DCIp, DCId)\n  colnames(DCI.results) <- c(\"DCIp\", \"DCId\")\n  DCI.results\n}\n\nDCI.results <- c(DCIp, DCId)\nprint(DCI.results)\n\n\n\n####\n#FUNCTION - DCId.calc: Calculated DCId\n#Segment 1 must be the first segment in the network that is the mouth at the ocean or river\n###\n\n\nif (pass2==0) pass2 <- nodefile$PermUS[i] * nodefile$PermDS[i]\nelse\n\n#Old version below\nall.paths <- NULL\nfor (k in 1:2) {\n  paths <- all_simple_paths(graph=g, from=k, mode = \"all\") #returns path from a segment to other segements\n  start <- sapply(paths, \"[[\", 1)\n  end <- sapply(paths, tail, 1)\n  \n  p.length <- NULL\n  pass <- NULL\n  for (j in 1:(nrow(nodes)-1)) {  \n    p.length2 <- 0\n    pass2 <- 0\n    for (i in paths[[j]]) {\n      p.length2 <- p.length2 + Area[i]\n      if (pass2==0) pass2 <- PermUS[i] * PermDS[i]\n      else\n        pass2 <- pass2 * (PermUS[i] * PermDS[i])\n    }\n    p.length <- c(p.length, p.length2)\n    pass <- c(pass, pass2)\n  }\n  all.paths2 <- data.frame(start, end, p.length, pass)\n  all.paths <- rbind(all.paths, all.paths2)\n}\n\n\n\n\n\nall.paths <- NULL\nfor (k in 1:nrow(nodes)) {\n  paths <- all_simple_paths(graph=g, from=k, mode = \"all\") #returns path from a segment to other segements\n  start <- sapply(paths, \"[[\", 1)\n  end <- sapply(paths, tail, 1)\n  \n  p.length <- NULL\n  pass <- NULL\n  for (j in 1:(nrow(nodes)-1)) {  \n    p.length2 <- 0\n    pass2 <- 0\n    for (i in paths[[j]]) {\n      p.length2 <- p.length2 + Area[i]\n      if (pass2==0) pass2 <- PermUS[i] * PermDS[i]\n      else\n        pass2 <- pass2 * (PermUS[i] * PermDS[i])\n    }\n    p.length <- c(p.length, p.length2)\n    pass <- c(pass, pass2)\n  }\n  all.paths2 <- data.frame(start, end, p.length, pass)\n  itself <- c(k, k, Area[k], PermUS[k]*PermUS[k])\n  all.paths <- rbind(all.paths, all.paths2, itself)\n}  \nall.paths$Start.Length <- nodes$Area[match(all.paths$start, nodes$ID)]\nall.paths$End.Length <- nodes$Area[match(all.paths$end, nodes$ID)]\n\n#DCIp Calculation\ntot.length <- sum(nodes$Area)\n\nDCIp <- 0\nfor (i in 1:nrow(all.paths)) {\n  DCIp <- DCIp + (all.paths$pass[i] * (all.paths$Start.Length[i]/tot.length) * (all.paths$End.Length[i]/tot.length))\n}\nDCIp",
    "created" : 1449274522160.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "654693839",
    "id" : "ED68744E",
    "lastKnownWriteTime" : 1449381244,
    "path" : "~/Stream fish Metapopulations/Scripts/DCI.R",
    "project_path" : "Scripts/DCI.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}