{
    "contents" : "library(igraph)\n\n#creates a random habitat network and identifies edges\ng <- barabasi.game(n=100, power=1, zero.appeal=1.3) # dendritic graph: n is number of patches, power=1, zero.appeal\nplot(g, layout=layout_with_fr, vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5) #plots g to see what is going on\n\n####\n#FUNCTION - Creates a random dendrictic network built from dwonstream to upstream\n#Code from\n#S. Kyle McKay, John R. Schramski, Jock N. Conyngham, and J. Craig Fischenich. 2013. \n#Assessing upstream fish passage connectivity with network analysis. Ecological Applications 23:1396-1409\n####\n\nnetwork <- function(n,tmax){\t\t\t\t\t#Function to create random adjacency matrix\n  A <- matrix(0,nrow=n,ncol=n)\t\t\t\t#Create an empty adjacency matrix\n  ntemp <- n\t\t\t\t\t\t#Reset counter for the number of nodes\n  ttemp <- tmax\t\t\t\t\t\t#Reset counter for the number of tributary junctions to insert\n  t <- 0\t\t\t\t\t\t\t#Reset counter for the realized number of tributary junctions\n  \n  for (j in 1:n){\n    split <- ifelse(round(runif(1,0,1),0)==1,1,0)\n    for (i in 1:n){\n      if(j>=i){A[i,j] <- 0}\t\t\t#Generate upstream connectivity using only the \"bottom\" of the matrix\n      else{\n        A[i,j] <- ifelse(i==j+1,1,ifelse(ttemp>0,split,0))\n      }\n      if(sum(A[i,])>1){A[i,j] <- 0}\t\t#Prevent network crossing\n      if(sum(A[,j])>2){A[i,j] <- 0}\t\t#Prevent more than one split at a node\n      if(i>j+1){ttemp <- ttemp - A[i,j]}\t#Reduce the available number of junctions left\n      ntemp <- ntemp - A[i,j]\t\t\t#Reduce the available number of nodes left\n    }\n    t <- ifelse(sum(A[,j])==2,t+1,t)\n  }\n  A\t\t\t\t\t\t\t#Send outputs\n}\n\nAplot <- network(50,10)\ng <- graph.adjacency(t(Aplot), mode=\"directed\")\t\t\t#Convert adjacency matrix to a graph object\nplot(g, layout=layout.reingold.tilford, vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5) #plot graph\n\n\n####\n#Set the size and qulaity of each of the nodes. These values can also be provided\n####\nArea <- sample(10:100, 50, replace=T) #Area of each row\nQual <- sample(0:100, 50, replace=T) #Relative quality of patch where 100 is high and 0 is low.\nnodes <- data.frame(Area, Qual)\n\n\n####\n#Get edges of a graph and then assign upstream and downstream permeability. These values can also be provided\n####\nedges <- data.frame(get.edgelist(g)) #get the edges of the graph\nedges$PermDS <- 100 #Assign permeability of each downstream connection between 0 and 100\nedges$PermUS <- 100 #Assign permeability of each upstream connection between 0 and 100\n\n\n####\n#FUNCTION\n#adds a specified number of dams to a list of edges from a graph. Dams have a permeability of 0\n####\nadd.dams <- function(edge, dams){\n  for(i in 1:dams){\n    edge[sample(1:nrow(nodes), 1), 4] <- 0\n  }\n  edge\n}\n\nedges.dam <- add.dams(edges, 10)\n\n\n####\n#FUNCTION\n#Calculates metapopulation mean lifetime for a graph with the following inputs\n#node is a dataframe with area and quality of each node\n#edge is a dataframe with two row detailing connections and weights/permeabilities\n#E Species specific coeffecint relating to patch size, between 1 and 100\n#N level of environmental variation in population growth, between 0.01 and 4. Small is more\n#U number of imigrants needed for succussful colonization\n#E, N, and U can be user defined but defaults are set currently\n####\n\nMMLT.def <- function(node, edge, E=1, N=0.5, U=2){\n  p <- nrow(nodes)\n  weights <- matrix(nrow=p, ncol=p) #creates matrix of edge weights read as row flows to col\n  for (i in 1:p)\n  {\n    weights[edge[i,1],edge[i,2]] <- edge[i,3]\n    weights[edge[i,2],edge[i,1]] <- edge[i,4]\n  }\n  weights[is.na(weights)] <- 0\n  \n  V<-E*(node$Area^(-N)) #Extinction Rate\n  \n  Uin <- calc.w.in(data=weights, V=V, n=p)\n  Uou <- apply(weights, 1, sum) #Colonization strength out \n  \n  Uset <- rbind(Uin, Uou)\n  \n  U1 <- apply(Uset, 2, function (x) 1/mean(1/x)) #Calculate harmonic mean\n  q <- prod(sapply(subset(U1, U1>0), function(x) x^(1/p))) #Agregate Colonization Rate\n  v <- prod(V) #Agregate Extinction Rate\n  \n  MLT=0\n  for (i in 1:p)\n  {\n    for (k in 1:p)\n    {\n      MLT <- MLT + ( (1/k) * (factorial(p-i)/factorial(p-k)) * (1/((p-1)^(k-i))) * (q^(k-i)) )\n    }\n  }\n  output <- cbind(p,E,N,U,MLT)\n  print(output)\n}\n\nMMLT.def(node=nodes, edge=edges, E=50, N=0.01, U=2)\n\n#Necessary function that must be run\ncalc.w.in <- function(data, V, n){ \n  weight <- NULL\n  for (j in 1:n){\n    weight1 <- 0\n    for (i in 1:n){\n      weight1 <- weight1 + data[i,j]/V[i]\n    }\n    weight <- c(weight, weight1)\n  }\n  weight\n}",
    "created" : 1448312923474.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "588143031",
    "id" : "CCCC3BA5",
    "lastKnownWriteTime" : 1448313030,
    "path" : "~/Stream fish Metapopulations/Scripts/MeanLifeTime.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}